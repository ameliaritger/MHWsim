---
title: "Population growth data analysis - count data"
author: "Amelia Ritger"
date: "2024-11-06"
output: html_document
---
# Load libraries
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(lme4) #glmer()
library(glarma) #glarma()
library(nlme) #lme()
library(knitr) #kable()
```

# Load Tidied Data
```{r, include = FALSE}
source("mergeAllData.R", local = knitr::knit_global())

#Load temperature data AFTER you have run source(ReadRPiData)
weekly_temp <- read_csv(here("experiment", "data", "weekly_temperature.csv"))
daily_temp <- read_csv(here("experiment", "data", "three_day_temperature.csv")) %>%
  mutate(date = if_else(date == ymd("2023-09-29"), ymd("2023-10-01"), date))
```

## Create tidied df
```{r}
all_size <- all %>%
  filter(!is.na(avg_size)) %>%
  mutate(avg_size_log = log(avg_size)) %>%
  group_by(tank, genet) %>%
  mutate(avg_size_diff = avg_size_log - lag(avg_size_log),
         avg_size_diff2 = avg_size_diff - lag(avg_size_diff)) %>%
  ungroup()
```

### Prepare data
```{r}
all_count <- all %>%
  #convert date to a numeric sequence
  mutate(date_num = as.numeric(as.Date(date)-min(as.Date(date))),
         mhw_binary = as.factor(ifelse(mhw == "during", 0, 1))) %>%
  dplyr::select(date_num, date, tank, genet, treatment, mhw, mhw_binary, n_true, growth_rate, growth_rate_cont) %>%
  rename(growth_rate_mhw = growth_rate) %>% #relabel for better understanding. growth_rate_mhw is where the growth rate resets to zero when the MHW ends. I believe I won't need growth_rate_mhw for GLARMA model because I can add state as a potential covariate.
  mutate(genet_tank = paste(tank, genet, sep = ""), #merge genet and tank because each unique genet x tank value is going to be autocorrelated
         intercept = 1) # create intercept of 1s for glarma

count_temp <- all_count %>%
  mutate(week = as.numeric(difftime(date, min(weekly_temp$friday), units = "weeks")) + 1,
         tank = as.numeric(tank)) %>%
  left_join(daily_temp, by = c("date", "tank"))
```

# Start analyses
## Check data distribution
```{r}
hist(all_count$growth_rate_cont, breaks = seq(min(all_count$growth_rate_cont), max(all_count$growth_rate_cont) + 0.5, by = 2), 
     main = "Histogram of Growth Rate", xlab = "Growth Rate", 
     ylab = "Frequency", col = "lightblue")

hist(all_count$n_true, breaks = seq(min(all_count$n_true)-0.5, max(all_count$n_true) + 0.5, by = 2), 
     main = "Histogram of Counts", xlab = "Count", 
     ylab = "Frequency", col = "lightblue")
```

## Define function for residual diagnostic plots
```{r}
# Define a function to plot residual diagnostics for a model
residual_diagnostics <- function(model) {
  # Extract residuals and fitted values
  residuals <- resid(model)
  fitted_values <- fitted(model)
  
  # 1. Residuals vs Fitted Plot (using ggplot2)
  ggplot(data.frame(fitted = fitted_values, residuals = residuals), aes(x = fitted, y = residuals)) +
    geom_point() +
    geom_smooth(method = "loess", color = "red") +  # smoothed line to detect trends
    labs(x = "Fitted values", y = "Residuals") +
    theme_minimal() +
    ggtitle("Residuals vs Fitted Plot")
  
  # 2. Set up the plot layout for two plots side by side (Base R plot)
  par(mfrow = c(1, 2)) # Layout for two plots side by side

  # 2a. Residuals vs Fitted Plot (Base R)
  plot(fitted_values, residuals, 
       xlab = "Fitted Values", 
       ylab = "Residuals", 
       main = "Residuals vs Fitted",
       pch = 16, col = "gray")
  abline(h = 0, col = "red", lty = 2) # Add a horizontal line at 0
  
  # 2b. Spread-Level Plot (Scale-Location Plot)
  plot(fitted_values, sqrt(abs(residuals)), 
       xlab = "Fitted Values", 
       ylab = "Sqrt(|Residuals|)", 
       main = "Spread-Level Plot",
       pch = 16, col = "gray")

  # 3. ACF and PACF of Residuals (Base R)
  acf(residuals, main = "ACF of Residuals")
  pacf(residuals, main = "PACF of Residuals")
  
  par(mfrow = c(1, 1)) # Layout for two plots side by side
  # 4. Q-Q plot of Residuals (Base R)
  qqnorm(residuals)
  qqline(residuals, col = "red")  # Add a red line to the Q-Q plot
}
```

## Define function to plot residuals
```{r}
plot_residuals <- function(model, model_name) {
  # Extract residuals and fitted values
  res <- residuals(model)
  fitted_values <- fitted(model)
  
  # Create a data frame for plotting
  residuals_data <- data.frame(
    Fitted = fitted_values,
    Residuals = res
  )
  
    # Residuals vs Fitted Plot
  p1 <- ggplot(residuals_data, aes(x = Fitted, y = Residuals)) +
    geom_point(alpha = 0.5) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
    labs(title = paste(model_name, " - Residuals vs Fitted"), 
         x = "Fitted Values", 
         y = "Residuals") +
    theme_minimal()
  
   # Histogram of Residuals
  p2 <- ggplot(residuals_data, aes(x = Residuals)) +
    geom_histogram(binwidth = 0.1, fill = "blue", color = "black", alpha = 0.7) +
    labs(title = paste(model_name, " - Histogram of Residuals"), 
         x = "Residuals", 
         y = "Frequency") +
    theme_minimal()
  
  # QQ Plot
  p3 <- ggplot(residuals_data, aes(sample = Residuals)) +
    geom_qq() +
    geom_qq_line(color = "red") +
    labs(title = paste(model_name, " - QQ Plot of Residuals")) +
    theme_minimal()
  
  # Print plots
  print(p1)
  print(p2)
  print(p3)
}
```

### Compare Poisson with NB model
```{r}
# Fit a Poisson model
poisson_growth <- glmer((growth_rate_cont+4) ~ treatment + date_num + (1|genet_tank), family = poisson, data = all_count)
poisson_n <- glmer(n_true ~ treatment + date_num + (1|genet_tank), family = poisson, data = all_count)

# Fit a Negative Binomial model
nb_growth <- glmer.nb((growth_rate_cont+4) ~ treatment + date_num + (1|genet_tank), data = all_count)
nb_n <- glmer.nb(n_true ~ treatment + date_num + (1|genet_tank), data = all_count)

# Compare models
AIC(poisson_growth, nb_growth, poisson_n, nb_n)
BIC(poisson_growth, nb_growth, poisson_n, nb_n)
```
NB is a better fit with random Tank effect, but Poisson is better fit with random GenetTank effect.

### Growth rate: QQ plot, chi square test, overdispersion ratio
```{r}
qqnorm(all_count$growth_rate_cont)
qqline(all_count$growth_rate_cont, col = "red")

# Create a table of observed counts
observed_counts <- table(all_count$growth_rate_cont)
# Calculate expected counts based on Poisson distribution
lambda <- mean(all_count$growth_rate_cont)
expected_counts <- dpois(as.numeric(names(observed_counts)), lambda) * length(observed_counts)
# Perform the Chi-squared test
chisq.test(observed_counts, p = expected_counts, rescale.p = TRUE)

growth_mean <- mean(all_count$growth_rate_cont)
growth_var <- var(all_count$growth_rate_cont)
# Check ratio
overdispersion_ratio <- growth_var / growth_mean
print(overdispersion_ratio) #growth rate is overdispersed

shapiro.test(all_count$growth_rate_cont)
```

### Counts: QQ plot, chi square test, overdispersion ratio
```{r}
qqnorm(all_count$n_true)
qqline(all_count$n_true, col = "red")

# Create a table of observed counts
observed_counts <- table(all_count$n_true)
# Calculate expected counts based on Poisson distribution
lambda <- mean(all_count$n_true)
expected_counts <- dpois(as.numeric(names(observed_counts)), lambda) * length(observed_counts)
# Perform the Chi-squared test
chisq.test(observed_counts, p = expected_counts, rescale.p = TRUE)

n_mean <- mean(all_count$n_true)
n_var <- var(all_count$n_true)
# Check ratio
overdispersion_ratio <- n_var / n_mean
print(overdispersion_ratio) #growth rate is overdispersed

shapiro.test(all_count$n_true)
```

Neither count data nor growth rate appear to follow poisson distribution. And both data metrics are overdispersed (mean << variance), so let's check with negative binomial distribution.

Growth rate contains negative numbers, which complicates the fact that it appears to follow negative binomial distribution. Let's focus on the raw count numbers for now and come back to growth rate later.

## GLARMA 
### Let's just jump straight into GLARMA and see what happens
```{r}
y <- all_count$n_true %>%
  as.matrix()
X <- model.matrix(n_true ~ treatment + genet + treatment:genet + mhw, data = all_count)
x <- model.matrix(n_true ~ treatment + genet + treatment:genet, data = all_count)

#glarma_model <- glarma(y, X, phiLags = c(1), type = "Poi", method = "FS", residuals = "Pearson", maxit = 100, grad = 1e-6)
glarma_model <- glarma(y, x, phiLags = c(1), type = "Poi", method = "FS", residuals = "Pearson", maxit = 100, grad = 1e-6)
glarma_model_state <- glarma(y, X, phiLags = c(1), type = "Poi", method = "FS", residuals = "Pearson", maxit = 100, grad = 1e-6)

summary(glarma_model)
summary(glarma_model_state)
#interaction model is better all around - which doesn't deviate from the GLMM
# adding in state (MHW before vs after) improves model fit
```

#### Let's test GLARMA models now with different lags and distributions
```{r}
glarma_model_nr <- glarma(y, x, phiLags = c(1), type = "Poi", method = "NR", residuals = "Pearson", maxit = 100, grad = 1e-6)
summary(glarma_model_nr) #no effect of NR vs FS other than computation time being faster for NR
#glarma_model_nb <- glarma(y, x, phiLags = c(1), type = "NegBin", method = "FS", residuals = "Pearson", maxit = 100, grad = 1e-6, alphaInit = 0.1)
#NegBin doesn't run --> WHY??????

#Let's just keep doing model comparison with different lags I guess...
glarma_model_2 <- glarma(y, x, phiLags = c(2), type = "Poi", method = "FS", residuals = "Pearson", maxit = 100, grad = 1e-6)
glarma_model_3 <- glarma(y, x, phiLags = c(3), type = "Poi", method = "FS", residuals = "Pearson", maxit = 100, grad = 1e-6)
glarma_model_8 <- glarma(y, x, phiLags = c(5), type = "Poi", method = "FS", residuals = "Pearson", maxit = 100, grad = 1e-6)
glarma_model_8 <- glarma(y, x, phiLags = c(6), type = "Poi", method = "FS", residuals = "Pearson", maxit = 100, grad = 1e-6)

print(c(extractAIC(glarma_model), extractAIC(glarma_model_2), extractAIC(glarma_model_3), extractAIC(glarma_model5), extractAIC(glarma_model6)))
#lag 6 has lowest AIC, lag 5 has second lowest AIC
summary(glarma_model)
summary(glarma_model_6)

glarma_model_1_2 <- glarma(y, x, phiLags = c(1:2), type = "Poi", method = "FS", residuals = "Pearson", maxit = 100, grad = 1e-6)
glarma_model_1_3 <- glarma(y, x, phiLags = c(1:3), type = "Poi", method = "FS", residuals = "Pearson", maxit = 100, grad = 1e-6)
glarma_model_1_6 <- glarma(y, x, phiLags = c(1:6), type = "Poi", method = "FS", residuals = "Pearson", maxit = 100, grad = 1e-6)
print(c(extractAIC(glarma_model), extractAIC(glarma_model_6), extractAIC(glarma_model_1_6)))
summary(glarma_model_1_6)

glarma_model_1_9 <- glarma(y, x, phiLags = c(1:9), type = "Poi", method = "FS", residuals = "Pearson", maxit = 100, grad = 1e-6)
glarma_model_1_15 <- glarma(y, x, phiLags = c(1:15), type = "Poi", method = "FS", residuals = "Pearson", maxit = 100, grad = 1e-6)
glarma_model_1_30 <- glarma(y, x, phiLags = c(1:30), type = "Poi", method = "FS", residuals = "Pearson", maxit = 100, grad = 1e-6)

glarma_model_30 <- glarma(y, x, phiLags = c(30), type = "Poi", method = "FS", residuals = "Pearson", maxit = 100, grad = 1e-6)

models <- list(
  glarma_model = glarma_model,
  glarma_model_2 = glarma_model_2,
  glarma_model_3 = glarma_model_3,
  glarma_model_4 = glarma_model_4,
  glarma_model_6 = glarma_model_6,
  glarma_model_30 = glarma_model_30,
  glarma_model_1_2 = glarma_model_1_2,
  glarma_model_1_6 = glarma_model_1_6,
  glarma_model_1_15 = glarma_model_1_15,
  glarma_model_1_30 = glarma_model_1_30
)

for (model_name in names(models)) {
  aic_value <- extractAIC(models[[model_name]])  # [2] extracts the AIC value
  aic_value <- format(aic_value, nsmall = 2)  # Format to 2 decimal places
  print(paste(model_name, "=", aic_value))
}
# grad = 2.22e-16 is a more computationally intensive/"precise" option

plot_residuals(glarma_model_1_12, "1-12")
plot_residuals(glarma_model_1_13, "1-13")
```
Between lag 1:12 and 1:13 is where the QQ plot and residuals plot changes shape significantly and shifts to a new regime

#### Check lags with day + week/month
```{r}
glarma_model_week <- glarma(y, x, phiLags = c(1, 2), type = "Poi", method = "FS", residuals = "Pearson", maxit = 100, grad = 1e-6)
glarma_model_2week <- glarma(y, x, phiLags = c(1, 4), type = "Poi", method = "FS", residuals = "Pearson", maxit = 100, grad = 1e-6)
glarma_model_month <- glarma(y, x, phiLags = c(1, 8), type = "Poi", method = "FS", residuals = "Pearson", maxit = 100, grad = 1e-6)
glarma_model_2month <- glarma(y, x, phiLags = c(1, 16), type = "Poi", method = "FS", residuals = "Pearson", maxit = 100, grad = 1e-6)

plot_residuals(glarma_model_2week, "day+2week")
plot_residuals(glarma_model_1_2, "dayTHROUGHweek")
plot_residuals(glarma_model_month, "day+1month")
plot_residuals(glarma_model_1_8, "dayTHROUGHmonth")
plot_residuals(glarma_model_2month, "day+2month")

plot.glarma(glarma_model_3)
plot.glarma(glarma_model_week)
plot.glarma(glarma_model_6)
plot.glarma(glarma_model_1_6)
```
All of these are way worse fits compared to the 1:12 models, at least in terms of residual gaps

### Add thetaLag
```{r}
glarma_model_theta <- glarma(y, x, thetaLags = c(1), type = "Poi", method = "FS", residuals = "Pearson", maxit = 100, grad = 1e-6)
extractAIC(glarma_model_theta)
extractAIC(glarma_model)
plot.glarma(glarma_model)
plot.glarma(glarma_model_theta)
```
Very similar fits, phiLag is slightly better AIC so let's just stick with phiLag

Glarma model with phiLags(1:36) is all around the best fit... but that seems fishy. Ask Chris! And let's move on.

Once you get to lags(1:36), the addition of the state variable doesn't matter (the model AICs are equivalent between phiLag(1:36) for model with state versus model without state) So... where to go from here? Probably compare with summaries. 

### Let's try working with the lagged count data?
```{r}
count_glarma_lag <- all_count %>%
  arrange(date) %>%
  group_by(tank, genet) %>%
  mutate(lag1 = lag(n_true, 1))

count_glarma_mhw <- all_count %>%
  filter(mhw == "during")
  
y2 <- count_glarma_mhw$n_true %>%
  as.matrix()
x2 <- model.matrix(n_true ~ treatment+genet, data = count_glarma_mhw)
glarma_model_mhwonly <- glarma(y2, x2, phiLags = c(1), type = "Poi", method = "FS", residuals = "Pearson", maxit = 100, grad = 1e-6)
plot_residuals(glarma_model_mhwonly, "Lag13")
plot.glarma(glarma_model_mhwonly)
fitted_values <- fitted(glarma_model_mhwonly)
result_df <- data.frame(PredictorVariables = x2, FittedValues = fitted_values) %>%
  filter(fitted_values < 15)

res <- residuals(glarma_model_mhwonly)
fitted_values <- fitted(glarma_model_mhwonly)

residuals_data <- data.frame(
    Fitted = fitted_values,
    Residuals = res
  )

ggplot(residuals_data, aes(x = Fitted, y = Residuals)) +
    geom_point(alpha = 0.5) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
    labs(title = paste(model_name, " - Residuals vs Fitted"), 
         x = "Fitted Values", 
         y = "Residuals") +
    theme_bw() 
```
No change, let's give up on GLARMA especially because no random effects allowed in model.

## LME with autocorrelation 

### Basic LME with corAR
```{r}
count_glmm1 <- lme(n_true ~ treatment + genet,
                   random = ~1|tank,
                   data = all_count,
                   correlation = corAR1(form = ~ 1|tank))
count_glmm2 <- lme(n_true ~ treatment + genet,
                   random = ~1|genet_tank,
                   data = all_count,
                   correlation = corAR1(form = ~ 1|genet_tank))
AIC(count_glmm1, count_glmm2)
BIC(count_glmm1, count_glmm2)
summary(count_glmm1)
summary(count_glmm2)

#genet_tank is definitely the correct "random effect" I need to incorporate, especially because it has lower residual standard dev and high autocorrelation (Phi) and MUCH lower AIC

count_glmm3 <- lme(n_true ~ treatment + genet + treatment:genet,
                   random = ~1|genet_tank,
                   data = all_count,
                   correlation = corAR1(form = ~ 1|genet_tank))

AIC(count_glmm2, count_glmm3)
BIC(count_glmm2, count_glmm3)
summary(count_glmm2)
summary(count_glmm3)

#even with added complexity and higher DF, count_glmm3 has a lower AIC suggesting the interaction improves the model fit significantly enough to outweigh the penalty from model complexity.

count_glmm4 <- lme(n_true ~ treatment + genet + treatment:genet, #same syntax as treatment*genet
                   random = ~1|genet_tank,
                   data = all_count,
                   correlation = corAR1())
AIC(count_glmm4, count_glmm3) #same AIC
BIC(count_glmm4, count_glmm3) #same BIC

count_glmm4b <- lme(n_true ~ treatment + genet + treatment:genet, #same syntax as treatment*genet
                   random = ~1|genet_tank,
                   data = all_count,
                   correlation = corAR1(form = ~ date_num | genet_tank))
AIC(count_glmm4, count_glmm4b) #date_num|genet_tank appears worse
BIC(count_glmm4, count_glmm4b) #date_num|genet_tank appears worse

residual_diagnostics(count_glmm3)
```
Residual plot looks off...

### Simpler models
```{r}
count_glmm5 <- lme(n_true ~ treatment,
                   random = ~1|genet_tank,
                   data = all_count,
                   correlation = corAR1(form = ~ 1|genet_tank))
count_glmm6 <- lme(n_true ~ genet,
                   random = ~1|genet_tank,
                   data = all_count,
                   correlation = corAR1(form = ~ 1|genet_tank))
summary(count_glmm5)
summary(count_glmm6)
AIC(count_glmm4, count_glmm5, count_glmm6)
BIC(count_glmm4, count_glmm5, count_glmm6)
#Treatment only is the worst AIC&BIC. so, treatment alone isn't best predictor.

count_glmm7 <- lme(n_true ~ treatment*genet + mhw,
                   random = ~1|genet_tank,
                   data = all_count,
                   correlation = corAR1(form = ~ 1|genet_tank))
AIC(count_glmm7) #adding during vs after MHW (state) is worse 
summary(count_glmm7)

count_glmm8 <- lme(n_true ~ treatment*mhw,
                   random = ~1|genet_tank,
                   data = all_count,
                   correlation = corAR1(form = ~ 1|genet_tank))
AIC(count_glmm8) #bad
```

At least for the GLMM, the treatment*genet with genet_tank random effect is best performing.

### Let's super simplify by only looking at during MHW
```{r}
all_count_mhw <- all_count %>%
  filter(mhw == "during")

count_glmm10 <- lme(n_true ~ treatment,
                   random = ~1|genet_tank,
                   data = all_count_mhw,
                   correlation = corAR1(form = ~ 1|genet_tank))

count_glmm11 <- lme(n_true ~ genet,
                   random = ~1|genet_tank,
                   data = all_count_mhw,
                   correlation = corAR1(form = ~ 1|genet_tank))

count_glmm12 <- lme(n_true ~ treatment*genet,
                   random = ~1|genet_tank,
                   data = all_count_mhw,
                   correlation = corAR1(form = ~ 1|genet_tank))

AIC(count_glmm10, count_glmm11, count_glmm12) #treatment alone still the worst
BIC(count_glmm10, count_glmm11, count_glmm12) #treatment alone still the worst

summary(count_glmm11)
summary(count_glmm12)
```
Treatment alone is the WORST, genet alone doesn't make a lot of sense especially when plotting the faceted data and my understanding of the experiment, so let's move forward with treatmentxgenet interaction model. 

### Let's try other correlation options
```{r}
autoArima <- auto.arima(all_count$n_true, seasonal = TRUE, stepwise = FALSE, approximation = FALSE)
summary(autoArima)

count_glmm13 <- lme(n_true ~ treatment*genet,
                   random = ~1|genet_tank,
                   data = all_count,
                   correlation = corARMA(p = 1, q = 1))

count_glmm14 <- lme(n_true ~ treatment*genet,
                   random = ~1|genet_tank,
                   data = all_count,
                   correlation = corARMA(p = 4, q = 1))

summary(count_glmm13)
summary(count_glmm14)
AIC(count_glmm13, count_glmm14, count_glmm4) #4 worst, 14 best
BIC(count_glmm13, count_glmm14, count_glmm4) #4 worst, 14 best

count_glmm15 <- lme(n_true ~ treatment*genet,
                   random = ~1|genet_tank,
                   data = all_count,
                   correlation = corCAR1(form = ~ date_num | genet_tank))
summary(count_glmm15)
AIC(count_glmm14, count_glmm15) #corARMA better
BIC(count_glmm14, count_glmm15) #corARMA better
```

### Let's look at "final" GLMM options with corARMA
```{r}
count_glmm14 <- lme(n_true ~ treatment*genet,
                   random = ~1|genet_tank,
                   data = all_count,
                   correlation = corARMA(p = 4, q = 1, form = ~ 1 | genet_tank))

count_glmm16 <- lme(n_true ~ treatment*genet + mhw,
                   random = ~1|genet_tank,
                   data = all_count,
                   correlation = corARMA(p = 4, q = 1, form = ~ 1 | genet_tank))

count_glmm17 <- lme(n_true ~ treatment*genet + mhw:treatment,
                   random = ~1|genet_tank,
                   data = all_count,
                   correlation = corARMA(p = 4, q = 1, form = ~ 1 | genet_tank),
                   control = lmeControl(maxIter = 100, msMaxIter = 100))
summary(count_glmm14)
summary(count_glmm16)
summary(count_glmm17)
AIC(count_glmm14, count_glmm16, count_glmm17) 
BIC(count_glmm14, count_glmm16, count_glmm17)
```
Adding in the "state" of the marine heatwave makes things worse all around / mhw isn't significant. Which I guess makes sense since even in the control the curves flattened out?

## Here's the "best" treatment model
```{r}
model_arma_treatment <- lme(n_true ~ treatment*genet,
                   random = ~1|genet_tank,
                   data = all_count,
                   correlation = corARMA(p = 4, q = 1, form = ~ 1 | genet_tank))

summary(model_arma_treatment)
model_final_table <- round(summary(model_arma_treatment)$tTable,4)
kable(model_final_table, digits = 3, caption = "Fixed Effects")

summary(emmeans(model_arma_treatment, pairwise ~ genet | avg_temp))
```

## Let's try this now with temperature rather than treatment

```{r}
model_with_ar1 <- lme(n_true ~ avg_temp*genet, 
                      random = ~ 1 | genet_tank,
                      correlation = corAR1(form = ~ 1 | genet_tank), 
                      data = count_temp)

model_with_arma <- lme(n_true ~ avg_temp*genet, 
                      random = ~ 1 | genet_tank,
                      correlation = corARMA(p = 4, q = 1, form = ~ 1 | genet_tank),
                      data = count_temp,
                      control = lmeControl(maxIter = 100, msMaxIter = 100))

anova(model_with_arma, model_with_ar1)
#ARMA best

model_with_arma2 <- lme(n_true ~ avg_temp*genet, 
                      random = ~ 1 | genet_tank,
                      correlation = corARMA(p = 4, q = 1, form = ~ date_num | genet_tank),
                      data = count_temp,
                      control = lmeControl(maxIter = 100, msMaxIter = 100))

anova(model_with_arma, model_with_arma2)
AIC(model_with_arma, model_with_arma2)
BIC(model_with_arma, model_with_arma2)

model_with_arma3 <- lme(n_true ~ avg_temp*genet+mhw, 
                      random = ~ 1 | genet_tank,
                      correlation = corARMA(p = 4, q = 1, form = ~ date_num | genet_tank),
                      data = count_temp,
                      control = lmeControl(maxIter = 100, msMaxIter = 100))

AIC(model_with_arma3, model_with_arma2)
BIC(model_with_arma3, model_with_arma2)

model_with_arma4 <- lme(n_true ~ avg_temp*genet*mhw, 
                      random = ~ 1 | genet_tank,
                      correlation = corARMA(p = 4, q = 1, form = ~ date_num | genet_tank),
                      data = count_temp,
                      control = lmeControl(maxIter = 100, msMaxIter = 100))

AIC(model_with_arma2, model_with_arma4)
BIC(model_with_arma2, model_with_arma4)

#arma2 best

model_with_arma5 <- lme(n_true ~ avg_temp*genet+date_num, 
                      random = ~ 1 | genet_tank,
                      correlation = corARMA(p = 4, q = 1, form = ~ date_num | genet_tank),
                      data = count_temp,
                      control = lmeControl(maxIter = 100, msMaxIter = 100))

AIC(model_with_arma2, model_with_arma5)
BIC(model_with_arma2, model_with_arma5)

#2 or 5 works, let's check residuals
residual_diagnostics(model_with_arma2)
residual_diagnostics(model_with_arma5) #WAAAAY better QQ plot and residualsxfitted plot
```

### Let's compare "best" ARMA plot with temp vs. treatment
```{r}
model_arma_treatment <- lme(n_true ~ treatment*genet+date_num,
                   random = ~1|genet_tank,
                   data = all_count,
                   correlation = corARMA(p = 4, q = 1, form = ~ 1 | genet_tank),
                   control = lmeControl(maxIter = 100, msMaxIter = 100))

model_arma_treatment2 <- lme(n_true ~ treatment*genet+date_num,
                   random = ~1|genet_tank,
                   data = all_count,
                   correlation = corARMA(p = 4, q = 1, form = ~ date_num | genet_tank),
                   control = lmeControl(maxIter = 100, msMaxIter = 100))

model_with_arma5 <- lme(n_true ~ avg_temp*genet+date_num, 
                      random = ~ 1 | genet_tank,
                      correlation = corARMA(p = 4, q = 1, form = ~ date_num | genet_tank),
                      data = count_temp,
                      control = lmeControl(maxIter = 100, msMaxIter = 100))

AIC(model_with_arma5, model_arma_treatment2)
BIC(model_with_arma5, model_arma_treatment2)

model_arma_treatment3 <- lme(n_true ~ treatment*genet*date_num,
                   random = ~1|genet_tank,
                   data = all_count,
                   correlation = corARMA(p = 4, q = 1, form = ~ date_num | genet_tank),
                   control = lmeControl(maxIter = 100, msMaxIter = 100))
anova(model_arma_treatment2, model_arma_treatment3)
AIC(model_arma_treatment3, model_arma_treatment2)
BIC(model_arma_treatment3, model_arma_treatment2) #2 is better, but *date_num is kinda what I'm asking

model_arma_treatment4 <- lme(n_true ~ treatment*genet*date_num,
                   random = ~date_num|genet_tank,
                   data = all_count,
                   correlation = corARMA(p = 1, q = 1, form = ~ date_num | genet_tank),
                   control = lmeControl(maxIter = 100, msMaxIter = 100))
model_arma_treatment5 <- lme(n_true ~ treatment*genet*date_num,
                   random = ~date_num|genet_tank,
                   data = all_count,
                   correlation = corAR1(form = ~ date_num | genet_tank),
                   control = lmeControl(maxIter = 100, msMaxIter = 100))

AIC(model_arma_treatment4, model_arma_treatment5)
BIC(model_arma_treatment4, model_arma_treatment5) #5 is better

model_arma_treatment6 <- lme(n_true ~ treatment*genet*date_num,
                   random = ~date_num|genet_tank,
                   data = all_count,
                   correlation = corAR1(form = ~ 1 | genet_tank),
                   control = lmeControl(maxIter = 100, msMaxIter = 100))
AIC(model_arma_treatment6, model_arma_treatment5)
BIC(model_arma_treatment6, model_arma_treatment5)
anova(model_arma_treatment6, model_arma_treatment5) #6 is much better
```

### Let's compare performance of really good fitting AR model
```{r}
model_with_arma_final <- lme(n_true ~ avg_temp*genet*date_num, 
                      random = ~ 1 | genet_tank,
                      correlation = corAR1(form = ~ 1 | genet_tank),
                      data = count_temp,
                      control = lmeControl(maxIter = 100, msMaxIter = 100))

model_ar1 <- lme(n_true ~ treatment*genet*date_num,
                   random = ~date_num|genet_tank,
                   data = all_count,
                   correlation = corAR1(form = ~ 1 | genet_tank),
                   control = lmeControl(maxIter = 100, msMaxIter = 100))

model_ar2 <- lme(n_true ~ treatment*genet*date_num,
                   random = ~1|genet_tank,
                   data = all_count,
                   correlation = corAR1(form = ~ 1 | genet_tank),
                   control = lmeControl(maxIter = 100, msMaxIter = 100))

AIC(model_ar1, model_ar2)
BIC(model_ar1, model_ar2)
anova(model_ar1, model_ar2)
residual_diagnostics(model_ar1)
residual_diagnostics(model_ar2)
residual_diagnostics(model_with_arma_final)

summary(model_ar1)
summary(model_ar2)
```


```{r}
ranef(model_ar1)
ranef(model_ar2)

ranefs_ar1 <- ranef(model_ar1)
ranefs_ar2 <- ranef(model_ar2)

# Plot random intercepts for each genet_tank
ggplot(ranefs_ar1, aes(x = `(Intercept)`, y = rownames(ranefs_ar1))) +
  geom_point() +
  labs(title = "Random Intercepts by genet_tank", x = "Random Intercept", y = "genet_tank") +
  theme_minimal()
ggplot(ranefs_ar2, aes(x = `(Intercept)`, y = rownames(ranefs_ar2))) +
  geom_point() +
  labs(title = "Random Intercepts by genet_tank", x = "Random Intercept", y = "genet_tank") +
  theme_minimal()

# Plot intercept vs slope
ggplot(ranefs_ar1, aes(x = `(Intercept)`, y = date_num)) +
  geom_point() +
  labs(title = "Random Intercepts vs Random Slopes", x = "Random Intercept", y = "Random Slope (date_num)") +
  theme_minimal()
```
Intercept vs slope plot linear increase supports that genets that initially have a higher initial population size also tend to show more rapid growth or accumulation over time. Makes sense!

Means I need to have the random effect be date_num | genet_tank

```{r}
model_ar1 <- lme(n_true ~ treatment*genet*date_num,
                   random = ~date_num|genet_tank,
                   data = all_count,
                   correlation = corAR1(form = ~ 1 | genet_tank),
                   control = lmeControl(maxIter = 100, msMaxIter = 100))

model_ar2 <- lme(n_true ~ treatment*genet+date_num,
                   random = ~date_num|genet_tank,
                   data = all_count,
                   correlation = corAR1(form = ~ 1 | genet_tank),
                   control = lmeControl(maxIter = 100, msMaxIter = 100))

AIC(model_ar1, model_ar2)
BIC(model_ar1, model_ar2)
residual_diagnostics(model_ar2)
residual_diagnostics(model_ar1) #2 is "best"

summary(model_ar2)

model_arma_treatment3 <- lme(n_true ~ treatment*genet+date_num,
                   random = ~date_num|genet_tank,
                   data = all_count,
                   correlation = corARMA(p = 1, q = 1, form = ~ 1 | genet_tank),
                   control = lmeControl(maxIter = 100, msMaxIter = 100))

residual_diagnostics(model_arma_treatment2)
residual_diagnostics(model_arma_treatment3)

plot(residuals(model_arma_treatment2))  # Plot residuals over time
acf(residuals(model_arma_treatment2))   # ACF of residuals
pacf(residuals(model_arma_treatment2))  # PACF of residuals
```
There is a trend in the residuals that is very strange (and the ACF/PACF suggest the model is not capturing the trends accurately), but I don't have time to keep troubleshooting without outside guidance so let's make a "good enough" model for WSN

## Here's the "final" model (pre-consultation) - What I'm presenting at WSN
```{r}
model_final <- lme(n_true ~ treatment*genet+date_num,
                   random = ~date_num|genet_tank,
                   data = all_count,
                   correlation = corAR1(form = ~ 1 | genet_tank),
                   control = lmeControl(maxIter = 100, msMaxIter = 100))

summary(model_final)
model_final_table <- round(summary(model_final)$tTable,4)
kable(model_final_table, digits = 3, caption = "Fixed Effects")

summary(emmeans(model_final, pairwise ~ genet | avg_temp))
```

. Fixed Effects: treatment*genet + date_num

    treatment * genet (Interaction of treatment and genet):
        What it represents: This is the interaction term between the two categorical variables treatment and genet. The interaction effect tests if the relationship between genet (e.g., genetic strain or group) and n_true is influenced by the type of treatment.
        Biological context: You are interested in whether the effect of treatment on the outcome n_true varies between genotypes (i.e., does the treatment have a different effect on different genetic lines?).
    date_num (Continuous term for time):
        What it represents: date_num is a continuous predictor representing time (likely in numerical form, such as days since the start of the experiment).
        Biological context: This variable accounts for the temporal progression of n_true. You're interested in how n_true changes over time, potentially as a function of the treatment, genotype, and their interactions.
    Why this matters: By including both main effects (treatment, genet, date_num) and their interaction, you're accounting for how the combination of these factors influences the rate of change in n_true over time. You’re testing if treatments affect different genotypes differently and how n_true evolves as time passes.

3. Random Effects: random = ~ date_num | genet_tank

    What it represents: This specifies random effects in the model. Specifically, date_num is included as a random slope for each genet_tank group. The genet_tank is a grouping factor (likely a combination of genetic group and tank identifier), and each genet_tank can have its own rate of change over time (date_num), allowing the model to capture individual variation in how n_true changes over time within each group.

    Biological context: In real-world experiments, different tanks (with different genetic groups) might have varying growth rates or changes in n_true over time. This random slope structure allows for these individual differences, ensuring that the model can account for the fact that not all tanks will have the same trajectory of change over time.

    Why this matters: By allowing random slopes for date_num, you are modeling the variability in how n_true increases or decreases over time within each genet_tank. This is important because some tanks might have a steeper or shallower rate of increase due to differences in tank conditions, initial starting point, or intrinsic genetic differences.

4. Autocorrelation Structure: correlation = corAR1(form = ~ 1 | genet_tank)

    What it represents: This specifies that the residuals (errors) of the model are autocorrelated within each genet_tank group, and the autocorrelation is modeled using an AR1 (autoregressive order 1) structure. The AR1 model assumes that the correlation between two residuals decreases exponentially with time.

    Biological context: In experiments where data are collected over time (such as repeated measures over several days), it is common for observations that are closer in time to be more correlated than those that are farther apart. This autocorrelation structure corrects for this temporal correlation in your residuals.

    Why this matters: Since your data are likely time-series (i.e., collected at multiple time points), accounting for autocorrelation ensures that you aren't treating consecutive time points as independent, which could lead to underestimating the uncertainty in your estimates. The AR1 structure ensures that your model is more realistic by acknowledging that the residuals from one time point will influence those at the next time point.

5. Data: data = all_count

    What it represents: This specifies the dataset that contains the variables used in the model.

    Biological context: all_count should contain the observed counts (n_true), the treatment types, genetic information, and the time points (i.e., date_num) that are used in the model. It’s crucial that this dataset is properly structured to represent the groups (genet_tank), treatments, and times in a way that fits the model.

    Why this matters: The data must be structured in a way that respects the hierarchical and repeated measures nature of your experiment. genet_tank groups need to be properly defined, and the dataset should include all necessary variables to allow the model to estimate the effects you're interested in.

6. Control Settings: control = lmeControl(maxIter = 100, msMaxIter = 100)

    What it represents: These control parameters set the maximum number of iterations for the optimization algorithm (for convergence). maxIter = 100 sets the maximum iterations for the main model fit, and msMaxIter = 100 sets the maximum for the fitting of the random effects.
    Why this matters: These settings ensure that the model fitting algorithm is allowed enough iterations to converge. In some cases, increasing these numbers may help the model to converge if it is struggling with local minima or complex fit.

Summary of the Model in the Context of Your Project:

    Fixed Effects (treatment, genet, date_num): The model is testing how n_true changes over time (date_num) and how the effect of time is influenced by the type of treatment and genet (genetic type). The interaction term (treatment*genet) tests whether the effect of treatment on the outcome varies between genotypes.

    Random Effects: By allowing random intercepts and slopes for each genet_tank, the model accounts for variation in the initial levels (n_true at the start) and the rate of change of n_true over time across different tanks. This is important because each tank may have different baseline counts and different rates of change due to biological and environmental factors.

    Autocorrelation: The use of an AR1 autocorrelation structure allows the model to account for temporal dependence in the data. This is particularly important when your data consist of repeated measurements over time, as the counts at one time point are often correlated with those at the next time point.

    Goal of the Model: You are trying to assess how n_true evolves over time in response to different treatments, and whether this change differs across genotypes, while also accounting for individual tank variations and the temporal correlation of measurements. This model allows you to properly assess the effect of the treatment and genotype on the growth (or change) of the biological entity, while correctly modeling the inherent structure and dependencies in your data.

# Plot something up for the GLMM

## Get started
```{r}
all_count_plot <- all_count %>%
  dplyr::select(date, tank, genet, genet_tank, treatment, n_true) %>%
  group_by(date, treatment, genet) %>%
  summarize(mean = mean(n_true),
            sd = sd(n_true),
            se = sd(n_true)/sqrt(length(n_true)),
            ci = qt(0.95, length(n_true)-1)*se,
            lower = mean - ci,
            upper = mean + ci) %>%
  dplyr::select(date, treatment, genet, mean, sd, lower, upper)


ggplot(all_count_plot, aes(x=date,color=genet)) +
  geom_point(aes(y=mean)) +
  #geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.2) +  # Error bars
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = genet), alpha = 0.2, color = NA) +  # Cloud effect
  facet_wrap(~treatment) +
  labs(x = "Date",
       y = "Count")

# Calculate residuals
all_count$residuals <- residuals(count_glmm14)

# Plot residuals
ggplot(all_count, aes(x = predicted, y = residuals)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  labs(x = "Predicted Values", y = "Residuals") +
  theme_minimal()

ggplot(all_count, aes(x = treatment, y = n_true, color = genet)) +
  geom_point(position = position_jitter(width = 0.2)) +
  stat_summary(fun = mean, geom = "line", aes(group = genet)) +
  labs(x = "Treatment", y = "n_true") +
  theme_minimal()
```

### Check dispersion
```{r}
all_count_dispersion <- all_count %>%
  group_by(genet_tank) %>%
  summarize(mean = mean(n_true),
            var = var(n_true),
            ratio = var/mean)

all_count_dispersion_genet <- all_count %>%
  group_by(genet) %>%
  summarize(mean = mean(n_true),
            var = var(n_true),
            ratio = var/mean)
```
Actually, if the data is organized by individual groupings (genet_tank OR genet only) it's not actually that overdispersed. Some of them are actually underdispersed. Let's keep this in mind for model interpretation. 

## Plot up count data for WSN 
### Treatment not significant
```{r}
all_count_treatment <- all_count %>%
  dplyr::select(date, tank, genet, genet_tank, treatment, n_true) %>%
  group_by(date, treatment) %>%
  summarize(mean = mean(n_true),
            sd = sd(n_true),
            se = sd(n_true)/sqrt(length(n_true)),
            ci = qt(0.95, length(n_true)-1)*se,
            lower = mean - ci,
            upper = mean + ci) %>%
  dplyr::select(date, treatment, mean, sd, lower, upper)

ggplot(all_count_treatment, aes(x=date, color=treatment)) +
  geom_vline(xintercept = as.numeric(as.Date("2023-12-12")), linetype = "dashed", color = "black", alpha = 0.8) +
  geom_smooth(aes(y=mean)) +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = treatment), alpha = 0.2, color = NA) +  # Cloud effect
  scale_color_manual(values = c("cold" = "#0072B2", "severe" = "#E69F00", "extreme" = "#D55E00"),
                     labels = c("cold" = "Ambient", "severe" = "Severe MHW", "extreme" = "Extreme MHW")) +  
  scale_fill_manual(values = c("cold" = "#0072B2", "severe" = "#E69F00", "extreme" = "#D55E00"),
                     labels = c("cold" = "Ambient", "severe" = "Severe MHW", "extreme" = "Extreme MHW")) +
  scale_x_date(date_labels = "%b %d", 
                   breaks= seq(min(all_count_treatment$date), max(all_count_treatment$date), length=7)) +
  labs(x = "Date",
       y = "Number of polyps",
       color = "") +
  guides(fill = "none",
         color=guide_legend(override.aes=list(fill=NA))) +
  theme_bw() +
  theme(text = element_text(size = 20),
        legend.position = "top")

#ggsave(here("experiment", "figures", "WSN", "count_mhw.png"), width=12, height=7)
#ggsave(file = here("experiment", "figures", "WSN","count_mhw.svg"), plot = image, width=12, height=7)
```

## Facet by genet, treatment
```{r}
ggplot(all_count_plot, aes(x=date,color=genet)) +
  geom_vline(xintercept = as.numeric(as.Date("2023-12-12")), linetype = "dashed", color = "black", alpha = 0.8) +
  geom_smooth(aes(y=mean), span = 0.5) +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = genet), alpha = 0.2, color = NA) +  # Cloud effect
  scale_color_manual(values = c("A" = "#9370DB", "B" = "#C21B78", "C" = "#FF9933", "D" ="#FF3333", "E" = "#662B45")) +
  scale_fill_manual(values = c("A" = "#9370DB", "B" = "#C21B78", "C" = "#FF9933", "D" ="#FF3333", "E" = "#662B45")) +
  facet_wrap(~treatment,
             labeller =  labeller(treatment = c("cold" = "Control", "severe" = "Severe MHW", "extreme" = "Extreme MHW"))) +
  scale_x_date(date_labels = "%b %d", 
                   breaks= seq(min(all_count_plot$date), max(all_count_plot$date), length=7)) +
  labs(x = "Date",
       y = "Number of polyps",
       color = "Genet") +
  guides(fill = "none",
         color=guide_legend(override.aes=list(fill=NA))) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        text = element_text(size = 20),
        legend.position = "top")

#ggsave(here("experiment", "figures", "WSN", "count_treatment_genet.png"), width=14, height=7)
#ggsave(file = here("experiment", "figures", "WSN","count_treatment_genet.svg"), plot = image, width=12, height=7)

ggplot(all_count_plot, aes(x=date,color=treatment)) +
  geom_vline(xintercept = as.numeric(as.Date("2023-12-12")), linetype = "dashed", color = "black", alpha = 0.8) +
  geom_smooth(aes(y=mean), span = 0.5) +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = treatment), alpha = 0.2, color = NA) +  # Cloud effect
  scale_color_manual(values = c("cold" = "#0072B2", "severe" = "#E69F00", "extreme" = "#D55E00"),
                     labels = c("cold" = "Ambient", "severe" = "Severe MHW", "extreme" = "Extreme MHW")) +  
  scale_fill_manual(values = c("cold" = "#0072B2", "severe" = "#E69F00", "extreme" = "#D55E00"),
                     labels = c("cold" = "Ambient", "severe" = "Severe MHW", "extreme" = "Extreme MHW")) +
  facet_wrap(~genet,
             scales = "free_y",
             labeller =  labeller(treatment = c("cold" = "Control", "severe" = "Severe MHW", "extreme" = "Extreme MHW"))) +
  scale_x_date(date_labels = "%b %d", 
                   breaks= seq(min(all_count_plot$date), max(all_count_plot$date), length=7)) +
  labs(x = "Date",
       y = "Number of polyps",
       color = "") +
  guides(fill = "none",
         color=guide_legend(override.aes=list(fill=NA))) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        text = element_text(size = 20),
        legend.position = "top")

#ggsave(file = here("experiment", "figures", "WSN","count_genet_treatment.svg"), plot = image, width=12, height=7)
```

## Genet only
```{r}
all_count_genet <- all_count %>%
  dplyr::select(date, tank, genet, genet_tank, treatment, n_true) %>%
  group_by(date, genet) %>%
  summarize(mean = mean(n_true),
            sd = sd(n_true),
            se = sd(n_true)/sqrt(length(n_true)),
            ci = qt(0.95, length(n_true)-1)*se,
            lower = mean - ci,
            upper = mean + ci) %>%
  dplyr::select(date,genet, mean, sd, lower, upper)

ggplot(all_count_genet, aes(x=date,color=genet)) +
  geom_vline(xintercept = as.numeric(as.Date("2023-12-12")), linetype = "dashed", color = "black", alpha = 0.8) +
  geom_smooth(aes(y=mean), span = 0.5) +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = genet), alpha = 0.2, color = NA) +  # Cloud effect
  scale_color_manual(values = c("A" = "#9370DB", "B" = "#C21B78", "C" = "#FF9933", "D" ="#FF3333", "E" = "#662B45")) +
  scale_fill_manual(values = c("A" = "#9370DB", "B" = "#C21B78", "C" = "#FF9933", "D" ="#FF3333", "E" = "#662B45")) +
  #facet_wrap(~treatment,
  #           labeller =  labeller(treatment = c("cold" = "Control", "severe" = "Severe MHW", "extreme" = "Extreme MHW"))) +
  scale_x_date(date_labels = "%b %d", 
                   breaks= seq(min(all_count_plot$date), max(all_count_plot$date), length=7)) +
  labs(x = "Date",
       y = "Number of polyps",
       color = "Genet") +
  guides(fill = "none",
         color=guide_legend(override.aes=list(fill=NA))) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        text = element_text(size = 20),
        legend.position = "top")

#ggsave(here("experiment", "figures", "WSN", "count_genet.png"), width=14, height=7)
```

## Interaction plot
```{r}
ggplot(all_count, aes(x = treatment, y = n_true, color = genet)) +
  geom_point(position = position_jitter(width = 0.2)) +
  stat_summary(fun = mean, geom = "line", aes(group = genet)) +
  labs(x = "Treatment", y = "n_true") +
  theme_minimal()
```


# Just for fun, let's only look at DURING MHW data

## Plot
```{r}
mhw_plot <- all_count %>%
  filter(mhw == "during") %>%
    dplyr::select(date, tank, genet, genet_tank, treatment, n_true) %>%
  group_by(date, treatment, genet) %>%
  summarize(mean = mean(n_true),
            sd = sd(n_true),
            se = sd(n_true)/sqrt(length(n_true)),
            ci = qt(0.95, length(n_true)-1)*se,
            lower = mean - ci,
            upper = mean + ci) %>%
  dplyr::select(date,treatment, genet, mean, sd, lower, upper)

ggplot(mhw_plot, aes(x=date,color=genet)) +
  #geom_vline(xintercept = as.numeric(as.Date("2023-12-12")), linetype = "dashed", color = "black", alpha = 0.8) +
  geom_smooth(aes(y=mean), span = 0.5) +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = genet), alpha = 0.2, color = NA) +  # Cloud effect
  scale_color_manual(values = c("A" = "#9370DB", "B" = "#C21B78", "C" = "#FF9933", "D" ="#FF3333", "E" = "#662B45")) +
  scale_fill_manual(values = c("A" = "#9370DB", "B" = "#C21B78", "C" = "#FF9933", "D" ="#FF3333", "E" = "#662B45")) +
  facet_wrap(~treatment,
             labeller =  labeller(treatment = c("cold" = "Control", "severe" = "Severe MHW", "extreme" = "Extreme MHW"))) +
  scale_x_date(date_labels = "%b %d", 
                   breaks= seq(min(all_count_plot$date), max(all_count_plot$date), length=7)) +
  labs(x = "Date",
       y = "Number of polyps",
       color = "Genet") +
  guides(fill = "none",
         color=guide_legend(override.aes=list(fill=NA))) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        text = element_text(size = 20),
        legend.position = "top")
```

## Model
```{r}
mhw <- all_count %>%
  filter(mhw == "during")

mhw_model <- lme(n_true ~ treatment*genet+date_num,
                   random = ~1|genet_tank,
                   data = mhw,
                   correlation = corAR1(form = ~ 1 | genet_tank),
                   control = lmeControl(maxIter = 100, msMaxIter = 100))

mhw_model2 <- lme(n_true ~ treatment*genet+date_num,
                   random = ~date_num|genet_tank,
                   data = mhw,
                   correlation = corAR1(form = ~ 1 | genet_tank),
                   control = lmeControl(maxIter = 100, msMaxIter = 100))

mhw_model3 <- lme(n_true ~ treatment+genet+date_num,
                   random = ~date_num|genet_tank,
                   data = mhw,
                   correlation = corAR1(form = ~ 1 | genet_tank),
                   control = lmeControl(maxIter = 100, msMaxIter = 100))

AIC(mhw_model, mhw_model3)
BIC(mhw_model, mhw_model3)

residual_diagnostics(mhw_model)
residual_diagnostics(mhw_model3)

summary(mhw_model)
summary(mhw_model3)
#no treatment interaction effect, model3 best
```
Even when removing all "recovery" data, there was still no effect of the treatment on growth rates. Only genet. 
